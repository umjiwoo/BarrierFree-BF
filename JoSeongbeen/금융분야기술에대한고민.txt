금융 분야는 새로운 기술을 적용하는 것에 개방적이지 않고 오히려 폐쇄적이다.

로직에서 새로움을 찾을 필요는 없다.

그 이유는 서비스의 유지와 보안이 중요하기 때문이다.

우리가 서버 유지와 보안에 대해서 생각하지 않고 기능의 구현에만 초점을 맞추다보니 별 거 하지 않게 되는 것 같다고 생각이 든 것 같다.

 

클라이언트의 수 많은 요청들을 엉킴 없이 처리하고 데이터베이스를 최적화하여 최대한 빠르게 데이터를 조회하거나 추가, 수정, 삭제할 수 있는 구조를 고안하고 유지하는 것이 중요하다. 또한 체계적인 로그 관리를 통해 문제점을 빠르게 파악하고 조치할 수 있는 시스템이 필요하다. 그리고 금융 분야는 돈에 관련되어 서버의 신뢰성에 굉장히 민감한 분야이기 때문에 어떻게 하면 서버 장애가 발생했을 때 빠르게 조치하거나 장애가 발생해도 서버를 유지할 수 있는 지를 생각해야 한다.

그런 면에서 몇 가지 고려 사항들을 조사해봤다.

1. 보안 및 전송 데이터 암호화
    1. 사용자 인증 및 권한 관리를 어떻게 강화할 수 있을 것인가?
    2. 데이터 암호화
        - 전송간에 데이터가 공격당해도 암호화처리를 통해 사용자의 데이터를 보호해야 한다.
        - SSL/TLS 등
    3. 규제 준수
        - 금융 데이터는 개인정보 보호법(PIPA), PCI DSS, KYC, AML 등 각종 규제를 준수해야 하므로, 법적 요구사항이 존재하고 이를 충족하는 보안 정책 수립이 필요하다.
    
2. 이벤트 소싱 및 CQRS
    
    대규모 트렌잭션 처리를 가능하게 하기 위해 상태 관리와 성능 최적화에 자주 사용되는 아키텍쳐 패턴
    
    1. 이벤트 소싱
        1. Application에서 발생하는 모든 상태 변경(즉, 이벤트)을 순차적이고 변경 불가능한 형태로 저장
        2. 저장된 이벤트를 순서대로 재생(Replay)함으로써, 언제든지 특정 시점의 상태를 재구성할 수 있다.
        3. 모든 변경 내역이 이벤트 로그에 기록되므로, 문제 발생 시 원인 추적이나 감사가 용이하다.
        4. 이벤트 기반 처리 덕분에 동시성 문제를 일부 완화할 수 있으며, 이벤트는 오직 추가(INSERT)만 발생하므로 데이터 무결성이 보장된다.
    2. CQRS
        1. 데이터를 수정하는 “명령(Command)”과 데이터를 읽어오는 “조회(Query)”를 완전히 분리
            - **Command Side**: 비즈니스 로직에 따른 데이터 변경(생성, 수정, 삭제)을 처리하며, 변경 내역은 주로 이벤트 소싱과 함께 기록됩니다.
            - **Query Side**: 사용자에게 빠르고 최적화된 읽기 서비스를 제공하기 위해 별도의 읽기 모델(Read Model)이나 데이터 저장소를 유지합니다.
        2. 예를 들어, 전통적인 은행 계좌 관리 시스템에서는 하나의 데이터베이스에서 계좌 정보의 생성, 수정, 조회를 모두 처리하지만, CQRS를 적용하면 명령 모델은 계좌 생성, 입금, 출금 등의 트랜잭션을 처리하고, 별도의 조회 모델은 사용자에게 빠른 계좌 잔액 조회나 거래 내역 조회 서비스를 제공하게 된다.
    3. 이벤트 소싱과 CQRS의 통합
        1. **결합 방식**
            - **이벤트 기록과 읽기 모델 업데이트**: Command Side에서 발생한 모든 상태 변경은 이벤트 소싱을 통해 이벤트로 기록되고, 이 이벤트들이 이벤트 핸들러나 프로젝터(Projector)를 통해 Query Side의 읽기 모델을 업데이트
            - **비동기 처리와 최종 일관성**: 명령 처리와 읽기 모델 업데이트 사이에 비동기 처리가 적용되어, 즉각적인 일관성보다는 최종 일관성(이벤트가 모두 반영된 후의 상태)을 보장
        2. **구현 예시**
            1. **명령 처리**: 계좌 생성, 입금, 출금 등의 작업을 처리할 때 각 작업마다 이벤트(예: AccountCreatedEvent, MoneyDepositedEvent 등)를 생성하고 이벤트 저장소에 기록
            2. **이벤트 발행 및 처리**: 저장된 이벤트는 이벤트 버스를 통해 구독되고, 이를 처리하는 이벤트 핸들러가 읽기 모델(예: AccountView)을 업데이트
            3. **조회 요청 처리**: 사용자는 업데이트된 읽기 모델을 통해 빠르게 현재 상태나 과거 상태를 조회
        3. 고려 사항
            - **스냅샷 관리**: 이벤트 로그가 길어질 경우, 주기적으로 스냅샷을 저장하여 상태 재구성 비용을 줄여야 한다.
            - **동시성 제어**: 여러 사용자가 동시에 같은 데이터를 변경할 때, 낙관적/비관적 락을 적용하여 이벤트 순서와 데이터 일관성을 유지해야 한다.
            - **최종 일관성 문제**: 명령과 조회 모델이 비동기적으로 동기화되므로, 사용자가 즉각적으로 최신 정보를 받지 못할 수 있다.
            - **운영 복잡성**: 두 모델을 별도로 운영하고 모니터링해야 하므로, 로그, 모니터링, 에러 핸들링 등 운영 측면의 추가적인 고려가 필요하다.

1. 고가용성 및 분산 트랜잭션 관리 (Saga 패턴, Two-Phase Commit 등)
    
    시스템의 구성 요소 중 일부가 장애를 겪더라도 전체 서비스가 계속 정상적으로 운영될 수 있도록 하는 설계 원칙이다. 금융 서비스처럼 24/7 운영이 필요한 시스템에서는 장애 시 빠른 복구와 무중단 서비스를 제공하는 것이 필수적이다.
    
    단일 실패 지점을 제거하고, 장애 발생 시 자동 복구, 즉각적인 장애 전환(Failover)을 통해 서비스 중단 시간을 최소화한다.
    
    1. **중복성(Replication) 및 클러스터링**:
        - 데이터베이스 및 애플리케이션 서버를 여러 노드에 복제하여, 하나의 노드에 장애가 발생하더라도 다른 노드가 그 역할을 대신하도록 구성
        - 예를 들어, 다중 데이터 센터 혹은 클라우드 리전 간 복제를 통해 지역별 장애에도 대비
    2. **로드 밸런싱 (Load Balancing)**:
        - 클라이언트 요청을 여러 서버에 분산하여 단일 서버에 과부하가 걸리지 않도록 한다.
        - 이는 장애 발생 시 자동으로 요청을 다른 서버로 전달하는 역할도 수행한다.
    3. **자동 장애 전환(Failover) 및 복구 메커니즘**:
        - 헬스 체크 및 모니터링 시스템을 통해 장애를 조기에 감지하고, 백업 시스템이나 예비 서버로 자동 전환할 수 있도록 구성한다.
        - 컨테이너 오케스트레이션(예: Kubernetes)이나 클라우드 네이티브 솔루션을 활용하면, 애플리케이션의 인스턴스를 자동으로 재시작하거나 스케일 아웃하는 방식으로 고가용성을 보장할 수 있다.